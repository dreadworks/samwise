/*  =========================================================================

    sam_selftest - run all self tests

    This Source Code Form is subject to the terms of the MIT
    License. If a copy of the MIT License was not distributed with
    this file, You can obtain one at http://opensource.org/licenses/MIT

    =========================================================================
*/
/**

   @brief run all self tests
   @file sam_selftest.c

   This file is used to offer an entry point to run all self
   tests. While there must not always appear a direct result in the
   terminal, it is very convenient to run all functions at least
   once. This checks if any inner assert signals SIGABRT and external
   programs can be used to check for memory leaks/segfaults and do
   heap profiling.

*/


#include "../include/sam_prelude.h"
#include "../include/samd.h"


// all of this should get autogenerated in the future
typedef void (*test_fn_t) ();


/// all possible functions
typedef enum {
    FN_ALL = 0,           ///< run all functions
    FN_SAM_LOG,           ///< for src/sam_log.c
    FN_SAM_GEN,           ///< for src/sam_gen.c
    FN_SAM_MSG,           ///< for src/sam_msg.c
    FN_SAM_BE_RMQ,        ///< for src/sam_be_rmq.c
    FN_SAM,               ///< for src/sam.c
    FN_SAMD               ///< for src/samd.c
} test_fn;


//  --------------------------------------------------------------------------
/// Print all necessary information for user invoking this
/// program. The function calls exit () with the provided return code.
static void
rtfm (int rc)
{
    printf ("sam selftest\n");
    printf ("usage: sam_selftest [-h] [--only SAM_MODULE]\n");
    printf ("options:\n");
    printf ("  -h: Print this message and exit\np");
    printf ("  --only SAM_MODULE: run test only for SAM_MODULE\n");
    printf ("    where SAM_MODULE is one of:\n");
    printf ("    samd, sam, sam_gen, sam_msg, sam_log, sam_be_rmq\n");
    printf ("\n");
    exit (rc);
}


//  --------------------------------------------------------------------------
/// Returns a pointer to a function based on the provided test_fn enum
/// value.
static test_fn_t
get_test_fn (test_fn fn)
{
    switch (fn) {

    case FN_SAM_LOG:
        return sam_log_test;

    case FN_SAM_GEN:
        return sam_gen_test;

    case FN_SAM_MSG:
        return sam_msg_test;

    case FN_SAM_BE_RMQ:
        return sam_be_rmq_test;

    case FN_SAM:
        return sam_test;

    case FN_SAMD:
        return samd_test;

    default:
        assert (false);
    }
}


//  --------------------------------------------------------------------------
/// Return the test_fn enum value for a given string.
static test_fn
get_fn_repr (char *name)
{
    if (!strcmp ("sam_log", name)) {
        return FN_SAM_LOG;
    }

    if (!strcmp ("sam_gen", name)) {
        return FN_SAM_GEN;
    }

    if (!strcmp ("sam_msg", name)) {
        return FN_SAM_MSG;
    }

    if (!strcmp ("sam_be_rmq", name)) {
        return FN_SAM_BE_RMQ;
    }

    if (!strcmp ("sam", name)) {
        return FN_SAM;
    }

    if (!strcmp ("samd", name)) {
        return FN_SAMD;
    }

    rtfm (2);
    return -1; // we never reach this
}


//  --------------------------------------------------------------------------
/// Parses input parameters and returns one of the enum options. Exits
/// the program for invalid arguments.
static test_fn
parse_args (int arg_c, char **arg_v)
{
    if (arg_c > 1) {

        if (!strcmp ("-h", arg_v[1])) {
            rtfm (0);
        }

        if (arg_c < 3 || 4 < arg_c || strcmp ("--only", arg_v[1])) {
            rtfm (2);
        }

        return get_fn_repr (arg_v[2]);
    }

    return FN_ALL;
}


//  --------------------------------------------------------------------------
/// Run tests.
int main (int arg_c, char **arg_v)
{
    test_fn fn = parse_args (arg_c, arg_v);

    if (fn == FN_ALL) {
        printf ("running all tests\n");
        test_fn fn_c = FN_ALL + 1;
        for (; fn_c <= FN_SAM; fn_c ++) {
            get_test_fn (fn_c) ();
        }
    } else {
        get_test_fn (fn) ();
    }
}
